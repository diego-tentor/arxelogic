<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Practical Examples - n-ary Logics</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
        }
        .container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin: 20px 0;
        }
        .logic-card {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin: 15px 0;
            border-left: 5px solid #667eea;
            transition: transform 0.3s ease;
        }
        .logic-card:hover {
            transform: translateX(10px);
        }
        .example {
            background: #e9ecef;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
        }
        .physical-app {
            background: #d4edda;
            border-left: 5px solid #28a745;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
        }
        .code {
            background: #2d3748;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
        }
        h1, h2, h3 {
            color: #2d3748;
        }
        .value-true { color: #28a745; font-weight: bold; }
        .value-false { color: #dc3545; font-weight: bold; }
        .value-undefined { color: #ffc107; font-weight: bold; }
        .analogy {
            background: #fff3cd;
            border-left: 5px solid #ffc107;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîç Practical Examples: n-ary Logics</h1>
        <p><strong>Key Concept:</strong> Different situations require different "types of truth"</p>

        <!-- L0: Contradiction -->
        <div class="logic-card">
            <h2>üé≠ L‚ÇÄ: When EVERYTHING is true and false simultaneously</h2>
            <div class="analogy">
                <strong>üí° Analogy:</strong> The Big Bang - before time and space, no distinctions exist
            </div>
            
            <div class="example">
                <strong>Practical Example:</strong> System state before initialization<br>
                <code>Does the user exist? = ‚ä§‚ä• (neither yes nor no, it's both)</code>
            </div>

            <div class="physical-app">
                <strong>Real Physical Application:</strong><br>
                - Singularities (black holes)<br>
                - Planck scale (limit of physical knowledge)<br>
                - Quantum state of the universe at t=0
            </div>

            <div class="code">
                // In code: Everything collapses to a single value<br>
                const result = systemBeforeInitialization();<br>
                console.log(result); // "‚ä§‚ä•" (indistinguishable)
            </div>
        </div>

        <!-- L1: Possibility -->
        <div class="logic-card">
            <h2>üîÑ L‚ÇÅ: When there are two options BUT you can't distinguish them</h2>
            <div class="analogy">
                <strong>üí° Analogy:</strong> An identical twin - you know there are two people but can't tell which is which
            </div>
            
            <div class="example">
                <strong>Practical Example:</strong> Symmetric encryption system<br>
                <code>Key A and Key B are functionally identical<br>
                There's no internal way to know which is "the correct one"</code>
            </div>

            <div class="physical-app">
                <strong>Real Physical Application:</strong><br>
                - Quantum vacuum fluctuations<br>
                - Identical particles (indistinguishable electrons)<br>
                - Symmetric states before symmetry breaking
            </div>

            <div class="code">
                // In code: Two indistinguishable values<br>
                const particle1 = 'a';<br>
                const particle2 = 'a‚Ä≤';<br>
                <br>
                // You can't decide which is "true"<br>
                if (particle1 === particle2) {<br>
                &nbsp;&nbsp;// Will never reach here! They are formally distinct<br>
                }<br>
                // But ontologically equivalent
            </div>
        </div>

        <!-- L2: Quantum Superposition -->
        <div class="logic-card">
            <h2>‚ö° L‚ÇÇ: When something IS and IS NOT at the same time (until you look)</h2>
            <div class="analogy">
                <strong>üí° Analogy:</strong> A coin spinning in the air - it's neither heads nor tails until it lands
            </div>
            
            <div class="example">
                <strong>Practical Example:</strong> Quantum cryptography<br>
                <code>The photon is in superposition: |0‚ü© + |1‚ü©<br>
                Only when measured does it collapse to 0 or 1</code>
            </div>

            <div class="physical-app">
                <strong>Real Physical Application:</strong><br>
                - Quantum computing (qubits in superposition)<br>
                - Double-slit experiment<br>
                - Quantum entanglement<br>
                - QKD cryptography (Quantum Key Distribution)
            </div>

            <div class="code">
                // In code: Three possible values<br>
                const qubit = '‚äó'; // Undecidable<br>
                <br>
                // Operations:<br>
                console.log(qubit + ' AND true =', '‚äó'); // Undecidable<br>
                console.log(qubit + ' OR false =', '‚äó'); // Undecidable<br>
                <br>
                // Only with observer (L‚ÇÉ) it collapses:<br>
                const result = measure(qubit); // '‚ä§' or '‚ä•'
            </div>
        </div>

        <!-- L3: Classical Logic with Observer -->
        <div class="logic-card">
            <h2>üëÅÔ∏è L‚ÇÉ: When an observer DECIDES reality</h2>
            <div class="analogy">
                <strong>üí° Analogy:</strong> A referee in a game - their decision makes a play "foul" or "not foul"
            </div>
            
            <div class="example">
                <strong>Practical Example:</strong> Voting system<br>
                <code>A proposal is "approved" or "rejected"<br>
                depending on the observer (evaluation committee)</code>
            </div>

            <div class="physical-app">
                <strong>Real Physical Application:</strong><br>
                - Quantum measurement (wave function collapse)<br>
                - Observer relativity<br>
                - Reference frames in relativity<br>
                - Observer effect in psychology
            </div>

            <div class="code">
                // In code: Classical logic but contextual<br>
                function isApproved(proposal, committee) {<br>
                &nbsp;&nbsp;// Different committees may decide differently<br>
                &nbsp;&nbsp;return committee.evaluate(proposal); // '‚ä§' or '‚ä•'<br>
                }<br>
                <br>
                // Same proposal, different results:<br>
                console.log(isApproved(proposal, committeeA)); // '‚ä§'<br>
                console.log(isApproved(proposal, committeeB)); // '‚ä•'
            </div>
        </div>

        <!-- L6: Bayesian -->
        <div class="logic-card">
            <h2>üìä L‚ÇÜ: When truth is a PROBABILITY</h2>
            <div class="analogy">
                <strong>üí° Analogy:</strong> Weather forecast - it's not "will rain" or "won't rain", it's "70% probability"
            </div>
            
            <div class="example">
                <strong>Practical Example:</strong> Recommendation system<br>
                <code>Will the user like this movie? = 0.83<br>
                "Truth" is a value between 0 and 1</code>
            </div>

            <div class="physical-app">
                <strong>Real Physical Application:</strong><br>
                - Quantum mechanics (Born rule)<br>
                - Artificial intelligence<br>
                - Probabilistic medical diagnosis<br>
                - Financial markets<br>
                - Machine Learning
            </div>

            <div class="code">
                // In code: Continuous values [0,1]<br>
                const rainProbability = 0.7;<br>
                const sunProbability = 0.3;<br>
                <br>
                // Bayesian update:<br>
                function updateProbability(prior, evidence) {<br>
                &nbsp;&nbsp;return (evidence * prior) / <br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(evidence * prior + (1-evidence)*(1-prior));<br>
                }<br>
                <br>
                console.log(updateProbability(0.5, 0.8)); // 0.73
            </div>
        </div>

        <!-- Integrated Example -->
        <div class="logic-card" style="background: #e7f3ff; border-left: 5px solid #007bff;">
            <h2>üîÑ INTEGRATED EXAMPLE: Quantum Security System</h2>
            
            <div class="example">
                <strong>Scenario:</strong> Secure communication using different logics at each stage
            </div>

            <div class="code">
                // 1. L‚ÇÄ: Initial system state<br>
                const initialState = '‚ä§‚ä•'; // Contradictory<br>
                <br>
                // 2. L‚ÇÅ: Generation of symmetric keys<br>
                const [keyA, keyB] = generateIndistinguishableKeys();<br>
                // keyA ‚â° keyB ontologically<br>
                <br>
                // 3. L‚ÇÇ: Transmission in quantum superposition<br>
                const photons = transmitInSuperposition(message);<br>
                // Each photon is in state |0‚ü© + |1‚ü©<br>
                <br>
                // 4. L‚ÇÉ: Measurement (observer decides reality)<br>
                const measuredBits = measurePhotons(photons);<br>
                // Collapses to '‚ä§' or '‚ä•'<br>
                <br>
                // 5. L‚ÇÜ: Probabilistic verification<br>
                const confidence = calculateConfidence(measuredBits);<br>
                // Example: 0.95 confidence that communication is secure
            </div>

            <div class="physical-app">
                <strong>Benefit:</strong> Each logic level adds a security layer:<br>
                - L‚ÇÄ: Unpredictable origin<br>
                - L‚ÇÅ: Indistinguishable keys<br>
                - L‚ÇÇ: Non-cloneable states (no-cloning theorem)<br>
                - L‚ÇÉ: Intruder detection (state changes when measured)<br>
                - L‚ÇÜ: Continuous security assessment
            </div>
        </div>

        <!-- Visual Summary -->
        <div class="logic-card" style="text-align: center; background: #fff; border: 2px dashed #667eea;">
            <h2>üìà VISUAL SUMMARY: When to use each logic?</h2>
            
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 20px 0;">
                <div style="padding: 15px; background: #ffebee; border-radius: 8px;">
                    <h4>L‚ÇÄ</h4>
                    <p>When NO distinctions exist<br>Origin/Singularity</p>
                </div>
                <div style="padding: 15px; background: #e8f5e8; border-radius: 8px;">
                    <h4>L‚ÇÅ</h4>
                    <p>When options exist BUT are indistinguishable</p>
                </div>
                <div style="padding: 15px; background: #e3f2fd; border-radius: 8px;">
                    <h4>L‚ÇÇ</h4>
                    <p>When something IS and IS NOT simultaneously (quantum)</p>
                </div>
                <div style="padding: 15px; background: #f3e5f5; border-radius: 8px;">
                    <h4>L‚ÇÉ</h4>
                    <p>When an OBSERVER decides reality</p>
                </div>
                <div style="padding: 15px; background: #fff8e1; border-radius: 8px;">
                    <h4>L‚ÇÜ</h4>
                    <p>When truth is a PROBABILITY</p>
                </div>
            </div>

            <div class="analogy">
                <strong>üöÄ Key Insight:</strong> There is no "single logic" for everything.<br>
                Reality operates with DIFFERENT rules at DIFFERENT levels,<br>
                and this system gives us the tools to model each level appropriately.
            </div>
        </div>
    </div>

    <script>
        // Simple interactive examples
        console.log("=== PRACTICAL DEMONSTRATION ===");
        
        // L‚ÇÇ Simulator (Quantum Superposition)
        class QuantumSimulator {
            constructor() {
                this.state = '‚äó'; // Undecidable
            }
            
            measure() {
                // Randomly collapses to ‚ä§ or ‚ä•
                this.state = Math.random() > 0.5 ? '‚ä§' : '‚ä•';
                return this.state;
            }
            
            operate(operator, otherState) {
                if (this.state === '‚äó' || otherState === '‚äó') {
                    return '‚äó'; // Undecidable propagates
                }
                
                // Classical logic for decided states
                if (operator === 'AND') {
                    return (this.state === '‚ä§' && otherState === '‚ä§') ? '‚ä§' : '‚ä•';
                } else if (operator === 'OR') {
                    return (this.state === '‚ä§' || otherState === '‚ä§') ? '‚ä§' : '‚ä•';
                }
            }
        }
        
        // Demonstration
        const qubit = new QuantumSimulator();
        console.log("Initial state:", qubit.state);
        console.log("Qubit AND True:", qubit.operate('AND', '‚ä§'));
        console.log("Measurement:", qubit.measure());
        console.log("After measurement - Qubit AND True:", qubit.operate('AND', '‚ä§'));
        
        // L‚ÇÜ Simulator (Bayesian)
        class MedicalDiagnosis {
            constructor() {
                this.diseaseProbability = 0.01; // 1% prevalence
            }
            
            updateWithTest(testEfficacy) {
                // P(disease|test+) = P(test+|disease)*P(disease) / P(test+)
                const pTestPositive = (testEfficacy * this.diseaseProbability) + 
                                    ((1 - testEfficacy) * (1 - this.diseaseProbability));
                
                this.diseaseProbability = (testEfficacy * this.diseaseProbability) / pTestPositive;
                return this.diseaseProbability;
            }
        }
        
        const patient = new MedicalDiagnosis();
        console.log("Initial disease probability:", patient.diseaseProbability);
        console.log("After positive test (95% efficacy):", 
                   patient.updateWithTest(0.95).toFixed(4));

        // Advanced Example: Multi-level logic system
        class MultiLevelSystem {
            constructor() {
                this.levels = {
                    L0: new L0System(),
                    L1: new L1System(),
                    L2: new QuantumSimulator(),
                    L3: new L3System(),
                    L6: new MedicalDiagnosis()
                };
            }

            simulateQuantumCommunication() {
                console.log("\n=== QUANTUM COMMUNICATION SIMULATION ===");
                
                // L0: Initial contradictory state
                console.log("L0 - Initial state:", this.levels.L0.getState());
                
                // L1: Generate indistinguishable keys
                const keys = this.levels.L1.generateKeys();
                console.log("L1 - Generated keys:", keys);
                
                // L2: Transmit in superposition
                const transmission = this.levels.L2;
                console.log("L2 - Transmission state:", transmission.state);
                
                // L3: Measure (observer decides)
                const measured = transmission.measure();
                console.log("L3 - Measured result:", measured);
                
                // L6: Calculate security confidence
                const confidence = this.calculateSecurityConfidence();
                console.log("L6 - Security confidence:", confidence.toFixed(4));
            }

            calculateSecurityConfidence() {
                // Simplified security assessment
                return 0.5 + Math.random() * 0.5; // 0.5 to 1.0
            }
        }

        class L0System {
            getState() {
                return '‚ä§‚ä•';
            }
        }

        class L1System {
            generateKeys() {
                return ['a', 'a‚Ä≤'];
            }
        }

        class L3System {
            evaluate(proposal, context) {
                // Different observers, different decisions
                return context === 'committeeA' ? '‚ä§' : '‚ä•';
            }
        }

        // Run the advanced simulation
        const advancedSystem = new MultiLevelSystem();
        advancedSystem.simulateQuantumCommunication();
    </script>
</body>
</html>